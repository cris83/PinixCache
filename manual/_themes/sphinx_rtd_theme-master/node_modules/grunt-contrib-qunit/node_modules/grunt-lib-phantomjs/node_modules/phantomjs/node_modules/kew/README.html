

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>kew: a lightweight (and super fast) promise/deferred framework for node.js &mdash; PINIX Cache Docs 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../../../../../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PINIX Cache Docs 1.0 documentation" href="../../../../../../../../../../index.html"/> 

  
  <script src="../../../../../../../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../../../../../../../index.html" class="icon icon-home"> PINIX Cache Docs
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../../../Global.html">Global</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../../../Origin.html">Origin</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../../../VHost.html">VHost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../../../VHost-Proxy.html">Virtual Host Proxy</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../../../../../../../index.html">PINIX Cache Docs</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../../../../../../../index.html">Docs</a> &raquo;</li>
      
    <li>kew: a lightweight (and super fast) promise/deferred framework for node.js</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../../../../../../../../_sources/_themes/sphinx_rtd_theme-master/node_modules/grunt-contrib-qunit/node_modules/grunt-lib-phantomjs/node_modules/phantomjs/node_modules/kew/README.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kew-a-lightweight-and-super-fast-promise-deferred-framework-for-node-js">
<h1>kew: a lightweight (and super fast) promise/deferred framework for node.js<a class="headerlink" href="#kew-a-lightweight-and-super-fast-promise-deferred-framework-for-node-js" title="Permalink to this headline">¶</a></h1>
<p><strong>kew</strong> is a lightweight promise framework with an aim of providing a base set of functionality similar to that provided by the [Q library](<a class="reference external" href="https://github.com/kriskowal/q">https://github.com/kriskowal/q</a> &#8220;Q&#8221;).</p>
<div class="section" id="a-few-answers-for-a-few-questions">
<h2>A few answers (for a few questions)<a class="headerlink" href="#a-few-answers-for-a-few-questions" title="Permalink to this headline">¶</a></h2>
<p><em>Why&#8217;d we write it?</em></p>
<p>During our initial usage of <strong>Q</strong> we found that it was consuming 80% of the cpu under load (primarily in chained database callbacks). We spent some time looking at patching <strong>Q</strong> and ultimately found that creating our own lightweight library for server-usage would suit our needs better than figuring out how to make a large cross-platform library more performant on one very specific platform.</p>
<p><em>So this does everything Q does?</em></p>
<p>Nope! <strong>Q</strong> is still an awesome library and does <em>way</em> more than <strong>kew</strong>. We support a tiny subset of the <strong>Q</strong> functionality (the subset that we happen to use in our actual use cases).</p>
</div>
<div class="section" id="what-are-promises">
<h2>What are Promises?<a class="headerlink" href="#what-are-promises" title="Permalink to this headline">¶</a></h2>
<p>At its core, a <em>Promise</em> is a promise to return a value at some point in the future. A <em>Promise</em> represents a value that will be (or may return an error if something goes wrong). <em>Promises</em> heavily reduce the complexity of asynchronous coding in node.js-like environments. Example:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>javascript
// assuming the getUrlContent() function exists and retrieves the content of a url
var htmlPromise = getUrlContent(myUrl)</p>
<p>// we can then filter that through an http parser (our imaginary parseHtml() function) asynchronously (or maybe synchronously, who knows)
var tagsPromise = htmlPromise.then(parseHtml)</p>
<p>// and then filter it through another function (getLinks()) which retrieves only the link tags
var linksPromise = tagsPromise.then(getLinks)</p>
<p>// and then parses the actual urls from the links (using parseUrlsFromLinks())
var urlsPromise = linksPromise.then(parseUrlsFromLinks)</p>
<p>// finally, we have a promise that should only provide us with the urls and will run once all the previous steps have ran
urlsPromise.then(function (urls) {</p>
<blockquote>
<div>// do something with the urls</div></blockquote>
<div class="section" id="id5">
<h3>})<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="how-do-i-use-kew">
<h2>How do I use <strong>kew</strong>?<a class="headerlink" href="#how-do-i-use-kew" title="Permalink to this headline">¶</a></h2>
<p>As a precursor to all the examples, the following code must be at the top of your page:</p>
<p><code class="docutils literal"><span class="pre">`javascript</span>
<span class="pre">var</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">require('kew')</span>
<span class="pre">`</span></code></p>
<p>### Convert a literal into a promise</p>
<p>The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.resolve() or Q.reject()</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)</p>
<p>// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
<a href="#id10"><span class="problematic" id="id11">``</span></a><a href="#id12"><span class="problematic" id="id13">`</span></a></p>
<p>In addition, you can create deferreds which can be used if you need to create a promise but resolve it later:</p>
<p><a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a>javascript
// create the deferreds
var successDefer = Q.defer()
var failDefer = Q.defer()</p>
<p>// resolve or reject the defers in 1 second
setTimeout(function () {</p>
<blockquote>
<div>successDefer.resolve(&#8220;ok&#8221;)
failDefer.reject(new Error(&#8220;this failed&#8221;))</div></blockquote>
<p>}, 1000)</p>
<p>// extract promises from the deferreds
var successPromise = successDefer.promise
var failPromise = failDefer.promise
<a href="#id18"><span class="problematic" id="id19">``</span></a><a href="#id20"><span class="problematic" id="id21">`</span></a></p>
<p>If you have a node-style callback (taking an <strong>Error</strong> as the first parameter and a response as the second), you can call the magic <cite>makeNodeResolver()</cite> function on a defer to allow the defer to handle the callbacks:</p>
<p><a href="#id22"><span class="problematic" id="id23">``</span></a><a href="#id24"><span class="problematic" id="id25">`</span></a>javascript
// create the deferred
var defer = Q.defer()</p>
<p>// some node-style function
getObjectFromDatabase(myObjectId, defer.makeNodeResolver())</p>
<p>// grab the output
defer.promise</p>
<blockquote>
<div><dl class="docutils">
<dt>.then(function (obj) {</dt>
<dd>// successfully retrieved the object</dd>
</dl>
<p>})
.fail(function (e) {</p>
<blockquote>
<div>// failed retrieving the object</div></blockquote>
<p>})</p>
</div></blockquote>
<p><a href="#id26"><span class="problematic" id="id27">``</span></a><a href="#id28"><span class="problematic" id="id29">`</span></a></p>
<p>### Handling successful results with <cite>.then()</cite></p>
<p>When a promise is resolved, you may call the <cite>.then()</cite> method to retrieve the value of the promise:</p>
<p><a href="#id30"><span class="problematic" id="id31">``</span></a><a href="#id32"><span class="problematic" id="id33">`</span></a>javascript
promise.then(function (result) {</p>
<blockquote>
<div>// do something with the result here</div></blockquote>
<div class="section" id="id34">
<h3>})<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<p><cite>.then()</cite> will in turn return a promise which will return the results of whatever it returns (asynchronously or not), allowing it to be chained indefinitely:</p>
<p><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>javascript
Q.resolve(&#8216;a&#8217;)</p>
<blockquote>
<div><dl class="docutils">
<dt>.then(function (result) {</dt>
<dd>return result + &#8216;b&#8217;</dd>
</dl>
<p>})
.then(function (result) {</p>
<blockquote>
<div>return result + &#8216;c&#8217;</div></blockquote>
<p>})
.then(function (result) {</p>
<blockquote>
<div>// result should be &#8216;abc&#8217;</div></blockquote>
<p>})</p>
</div></blockquote>
<p><a href="#id39"><span class="problematic" id="id40">``</span></a><a href="#id41"><span class="problematic" id="id42">`</span></a></p>
<p>In addition, <cite>.then()</cite> calls may return promises themselves, allowing for complex nesting of asynchronous calls in a flat manner:</p>
<p><a href="#id43"><span class="problematic" id="id44">``</span></a><a href="#id45"><span class="problematic" id="id46">`</span></a>javascript
var htmlPromise = getUrlContent(myUrl)</p>
<dl class="docutils">
<dt>var tagsPromise = htmlPromise.then(function (html) {</dt>
<dd><p class="first">if (!validHtml(html)) throw new Error(&#8220;Invalid HTML&#8221;)</p>
<p class="last">// pretend that parseHtml() returns a promise and is asynchronous
return parseHtml(html)</p>
</dd>
</dl>
</div>
<div class="section" id="id47">
<h3>})<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h3>
<p>### Handling errors with <cite>.fail()</cite></p>
<p>If a promise is rejected for some reason, you may handle the failure case with the <cite>.fail()</cite> function:</p>
<p><a href="#id48"><span class="problematic" id="id49">``</span></a><a href="#id50"><span class="problematic" id="id51">`</span></a>javascript
getObjectPromise</p>
<blockquote>
<div><dl class="docutils">
<dt>.fail(function (e) {</dt>
<dd>console.error(&#8220;Failed to retrieve object&#8221;, e)</dd>
</dl>
<p>})</p>
</div></blockquote>
<p><a href="#id52"><span class="problematic" id="id53">``</span></a><a href="#id54"><span class="problematic" id="id55">`</span></a></p>
<p>Like <cite>.then()</cite>, <cite>.fail()</cite> also returns a promise. If the <cite>.fail()</cite> call does not throw an error, it will pass the return value of the <cite>.fail()</cite> handler to any <cite>.then()</cite> calls chained to it:</p>
<p><a href="#id56"><span class="problematic" id="id57">``</span></a><a href="#id58"><span class="problematic" id="id59">`</span></a>javascript
getObjectPromise</p>
<blockquote>
<div><dl class="docutils">
<dt>.fail(function (e) {</dt>
<dd>return retryGetObject(objId)</dd>
</dl>
<p>})
.then(function (obj) {</p>
<blockquote>
<div>// yay, we received an object</div></blockquote>
<p>})
.fail(function (e) {</p>
<blockquote>
<div>// the retry failed :(
console.error(&#8220;Retrieving the object &#8216;&#8221; + objId + &#8220;&#8217; failed&#8221;)</div></blockquote>
<p>})</p>
</div></blockquote>
</div>
<div class="section" id="id60">
<h3>})<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h3>
<p>If you&#8217;ve reached the end of your promise chain, you may call <cite>.end()</cite> which signifies that the promise chain is ended and any errors should be thrown in whatever scope the code is currently in:</p>
<p><a href="#id61"><span class="problematic" id="id62">``</span></a><a href="#id63"><span class="problematic" id="id64">`</span></a>javascript
getObjectPromise</p>
<blockquote>
<div>// this will throw an error to the uncaught exception handler if the getObjectPromise call is asynchronous
.end()</div></blockquote>
<p><a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a></p>
<p>### <cite>.fin()</cite> when things are finished</p>
<p>You may attach a handler to a promise which will be ran regardless of whether the promise was resolved or rejected (but will only run upon completion). This is useful in the cases where you may have set up resources to run a request and wish to tear them down afterwards. <cite>.fin()</cite> will return the promise it is called upon:</p>
<p><a href="#id69"><span class="problematic" id="id70">``</span></a><a href="#id71"><span class="problematic" id="id72">`</span></a>javascript
var connection = db.connect()</p>
<dl class="docutils">
<dt>var itemPromise = db.getItem(itemId)</dt>
<dd><dl class="first docutils">
<dt>.fin(function () {</dt>
<dd>db.close()</dd>
</dl>
<p class="last">})</p>
</dd>
</dl>
<p><a href="#id73"><span class="problematic" id="id74">``</span></a><a href="#id75"><span class="problematic" id="id76">`</span></a></p>
</div>
</div>
<div class="section" id="other-utility-methods">
<h2>Other utility methods<a class="headerlink" href="#other-utility-methods" title="Permalink to this headline">¶</a></h2>
<p>### <cite>.all()</cite> for many things</p>
<p>If you&#8217;re waiting for multiple promises to return, you may pass them (mixed in with literals if you desire) into <cite>.all()</cite> which will create a promise that resolves successfully with an array of the results of the promises:</p>
<p><a href="#id77"><span class="problematic" id="id78">``</span></a><a href="#id79"><span class="problematic" id="id80">`</span></a>javascript
var promises = []
promises.push(getUrlContent(url1))
promises.push(getUrlContent(url2))
promises.push(getUrlContent(url3))</p>
<dl class="docutils">
<dt>Q.all(promises)</dt>
<dd><dl class="first docutils">
<dt>.then(function (content) {</dt>
<dd>// content[0] === content for url 1
// content[1] === content for url 2
// content[2] === content for url 3</dd>
</dl>
<p class="last">})</p>
</dd>
</dl>
<p><a href="#id81"><span class="problematic" id="id82">``</span></a><a href="#id83"><span class="problematic" id="id84">`</span></a></p>
<p>If any of the promises fail, Q.all will fail as well (so make sure to guard your promises with a <cite>.fail()</cite> call beforehand if you don&#8217;t care whether they succeed or not):</p>
<p><a href="#id85"><span class="problematic" id="id86">``</span></a><a href="#id87"><span class="problematic" id="id88">`</span></a>javascript
var promises = []
promises.push(getUrlContent(url1))
promises.push(getUrlContent(url2))
promises.push(getUrlContent(url3))</p>
<dl class="docutils">
<dt>Q.all(promises)</dt>
<dd><dl class="first docutils">
<dt>.fail(function (e) {</dt>
<dd>console.log(&#8220;Failed retrieving a url&#8221;, e)</dd>
</dl>
<p class="last">})</p>
</dd>
</dl>
<p><a href="#id89"><span class="problematic" id="id90">``</span></a><a href="#id91"><span class="problematic" id="id92">`</span></a></p>
<p>### <cite>.delay()</cite> for future promises</p>
<p>If you need a little bit of delay (such as retrying a method call to a service that is &#8220;eventually consistent&#8221;) before doing something else, <code class="docutils literal"><span class="pre">Q.delay()</span></code> is your friend:</p>
<p><a href="#id93"><span class="problematic" id="id94">``</span></a><a href="#id95"><span class="problematic" id="id96">`</span></a>javascript
getUrlContent(url1)
.fail(function () {</p>
<blockquote>
<div><p>// Retry again after 200 milisseconds
return Q.delay(200).then(function () {</p>
<blockquote>
<div>return getUrlContent(url1)</div></blockquote>
<p>})</p>
</div></blockquote>
<div class="section" id="id97">
<h3>})<a class="headerlink" href="#id97" title="Permalink to this headline">¶</a></h3>
<p>If two arguments are passed, the first will be used as the return value, and the
second will be the delay in milliseconds.</p>
<p><a href="#id98"><span class="problematic" id="id99">``</span></a><a href="#id100"><span class="problematic" id="id101">`</span></a>javascript
Q.delay(obj, 20).then(function (result) {</p>
<blockquote>
<div>console.log(result) // logs <cite>obj</cite> after 20ms</div></blockquote>
</div>
<div class="section" id="id102">
<h3>})<a class="headerlink" href="#id102" title="Permalink to this headline">¶</a></h3>
<p>### <cite>.fcall()</cite> for delaying a function invocation until the next tick:
<a href="#id103"><span class="problematic" id="id104">``</span></a><a href="#id105"><span class="problematic" id="id106">`</span></a>javascript
// Assume someFn() is a synchronous 2 argument function you want to delay.
Q.fcall(someFn, arg1, arg2)</p>
<blockquote>
<div><dl class="docutils">
<dt>.then(function (result) {</dt>
<dd>console.log(&#8216;someFn(&#8216; + arg1 + &#8216;, &#8216; + arg2 + &#8216;) = &#8216; + result)</dd>
</dl>
<p>})</p>
</div></blockquote>
<p><a href="#id107"><span class="problematic" id="id108">``</span></a><a href="#id109"><span class="problematic" id="id110">`</span></a></p>
<p>You can also use <code class="docutils literal"><span class="pre">Q.fcall()</span></code> with functions that return promises.</p>
<p>### <cite>.nfcall()</cite> for Node.js callbacks</p>
<p><code class="docutils literal"><span class="pre">Q.nfcall()</span></code> can be used to convert node-style callbacks into promises:</p>
<p><a href="#id111"><span class="problematic" id="id112">``</span></a><a href="#id113"><span class="problematic" id="id114">`</span></a>javascript
Q.nfcall(fs.writeFile, &#8216;/tmp/myFile&#8217;, &#8216;content&#8217;)</p>
<blockquote>
<div><dl class="docutils">
<dt>.then(function () {</dt>
<dd>console.log(&#8216;File written successfully&#8217;)</dd>
</dl>
<p>})
.fail(function (err) {</p>
<blockquote>
<div>console.log(&#8216;Failed to write file&#8217;, err)</div></blockquote>
<p>})</p>
</div></blockquote>
<p><a href="#id115"><span class="problematic" id="id116">``</span></a><a href="#id117"><span class="problematic" id="id118">`</span></a></p>
</div>
</div>
<div class="section" id="contributing">
<h2>Contributing<a class="headerlink" href="#contributing" title="Permalink to this headline">¶</a></h2>
<p>Questions, comments, bug reports, and pull requests are all welcome.
Submit them at [the project on GitHub](<a class="reference external" href="https://github.com/Obvious/kew/">https://github.com/Obvious/kew/</a>).</p>
<p>Bug reports that include steps-to-reproduce (including code) are the
best. Even better, make them in the form of pull requests that update
the test suite. Thanks!</p>
</div>
<div class="section" id="author">
<h2>Author<a class="headerlink" href="#author" title="Permalink to this headline">¶</a></h2>
<p>[Jeremy Stanley](<a class="reference external" href="https://github.com/azulus">https://github.com/azulus</a>)
supported by
[The Obvious Corporation](<a class="reference external" href="http://obvious.com/">http://obvious.com/</a>).</p>
</div>
<div class="section" id="license">
<h2>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h2>
<p>Copyright 2013 [The Obvious Corporation](<a class="reference external" href="http://obvious.com/">http://obvious.com/</a>).</p>
<p>Licensed under the Apache License, Version 2.0.
See the top-level file <cite>LICENSE.TXT</cite> and
(<a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>).</p>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright © NFLabs. All rights reserved..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../../../../../../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../../../../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../../../../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../../../../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../../../../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>