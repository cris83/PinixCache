

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>}); &mdash; PINIX Cache Docs 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../../../../../../../../../../../../../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PINIX Cache Docs 1.0 documentation" href="../../../../../../../../../../../../../../../../../../index.html"/> 

  
  <script src="../../../../../../../../../../../../../../../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../../../../../../../../../../../../../../../index.html" class="icon icon-home"> PINIX Cache Docs
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../../../../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../../../../../../../../../../../Global.html">Global</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../../../../../../../../../../../Origin.html">Origin</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../../../../../../../../../../../VHost.html">VHost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../../../../../../../../../../../VHost-Proxy.html">Virtual Host Proxy</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../../../../../../../../../../../../../../../index.html">PINIX Cache Docs</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../../../../../../../../../../../../../../../index.html">Docs</a> &raquo;</li>
      
    <li>});</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../../../../../../../../../../../../../../../../_sources/_themes/sphinx_rtd_theme-master/node_modules/grunt-contrib-imagemin/node_modules/imagemin/node_modules/imagemin-optipng/node_modules/optipng-bin/node_modules/bin-build/node_modules/download/node_modules/request/node_modules/hawk/README.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>![hawk Logo](<a class="reference external" href="https://raw.github.com/hueniverse/hawk/master/images/hawk.png">https://raw.github.com/hueniverse/hawk/master/images/hawk.png</a>)</p>
<p>&lt;img align=&#8221;right&#8221; src=&#8221;<a class="reference external" href="https://raw.github.com/hueniverse/hawk/master/images/logo.png">https://raw.github.com/hueniverse/hawk/master/images/logo.png</a>&#8221; /&gt; <strong>Hawk</strong> is an HTTP authentication scheme using a message authentication code (MAC) algorithm to provide partial
HTTP request cryptographic verification. For more complex use cases such as access delegation, see [Oz](<a class="reference external" href="https://github.com/hueniverse/oz">https://github.com/hueniverse/oz</a>).</p>
<p>Current version: <strong>3.x</strong></p>
<p>Note: 3.x and 2.x are the same exact protocol as 1.1. The version increments reflect changes in the node API.</p>
<p>[![Build Status](<a class="reference external" href="https://secure.travis-ci.org/hueniverse/hawk.png)](http://travis-ci.org/hueniverse/hawk">https://secure.travis-ci.org/hueniverse/hawk.png)](http://travis-ci.org/hueniverse/hawk</a>)</p>
<p># Table of Content</p>
<ul>
<li><p class="first">[<strong>Introduction</strong>](#introduction)
- [Replay Protection](#replay-protection)
- [Usage Example](#usage-example)
- [Protocol Example](#protocol-example)</p>
<blockquote>
<div><ul class="simple">
<li>[Payload Validation](#payload-validation)</li>
<li>[Response Payload Validation](#response-payload-validation)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>[Browser Support and Considerations](#browser-support-and-considerations)</li>
</ul>
</li>
</ul>
<p>&lt;p&gt;&lt;/p&gt;
- [<strong>Single URI Authorization</strong>](#single-uri-authorization)</p>
<blockquote>
<div><ul class="simple">
<li>[Usage Example](#bewit-usage-example)</li>
</ul>
</div></blockquote>
<p>&lt;p&gt;&lt;/p&gt;
- [<strong>Security Considerations</strong>](#security-considerations)</p>
<blockquote>
<div><ul class="simple">
<li>[MAC Keys Transmission](#mac-keys-transmission)</li>
<li>[Confidentiality of Requests](#confidentiality-of-requests)</li>
<li>[Spoofing by Counterfeit Servers](#spoofing-by-counterfeit-servers)</li>
<li>[Plaintext Storage of Credentials](#plaintext-storage-of-credentials)</li>
<li>[Entropy of Keys](#entropy-of-keys)</li>
<li>[Coverage Limitations](#coverage-limitations)</li>
<li>[Future Time Manipulation](#future-time-manipulation)</li>
<li>[Client Clock Poisoning](#client-clock-poisoning)</li>
<li>[Bewit Limitations](#bewit-limitations)</li>
<li>[Host Header Forgery](#host-header-forgery)</li>
</ul>
</div></blockquote>
<p>&lt;p&gt;&lt;/p&gt;
- [<strong>Frequently Asked Questions</strong>](#frequently-asked-questions)
&lt;p&gt;&lt;/p&gt;
- [<strong>Implementations</strong>](#implementations)
- [<strong>Acknowledgements</strong>](#acknowledgements)</p>
<p># Introduction</p>
<p><strong>Hawk</strong> is an HTTP authentication scheme providing mechanisms for making authenticated HTTP requests with
partial cryptographic verification of the request and response, covering the HTTP method, request URI, host,
and optionally the request payload.</p>
<p>Similar to the HTTP [Digest access authentication schemes](<a class="reference external" href="http://www.ietf.org/rfc/rfc2617.txt">http://www.ietf.org/rfc/rfc2617.txt</a>), <strong>Hawk</strong> uses a set of
client credentials which include an identifier (e.g. username) and key (e.g. password). Likewise, just as with the Digest scheme,
the key is never included in authenticated requests. Instead, it is used to calculate a request MAC value which is
included in its place.</p>
<p>However, <strong>Hawk</strong> has several differences from Digest. In particular, while both use a nonce to limit the possibility of
replay attacks, in <strong>Hawk</strong> the client generates the nonce and uses it in combination with a timestamp, leading to less
&#8220;chattiness&#8221; (interaction with the server).</p>
<p>Also unlike Digest, this scheme is not intended to protect the key itself (the password in Digest) because
the client and server must both have access to the key material in the clear.</p>
<p>The primary design goals of this scheme are to:
* simplify and improve HTTP authentication for services that are unwilling or unable to deploy TLS for all resources,
* secure credentials against leakage (e.g., when the client uses some form of dynamic configuration to determine where</p>
<blockquote>
<div>to send an authenticated request), and</div></blockquote>
<ul class="simple">
<li>avoid the exposure of credentials sent to a malicious server over an unauthenticated secure channel due to client
failure to validate the server&#8217;s identity as part of its TLS handshake.</li>
</ul>
<p>In addition, <strong>Hawk</strong> supports a method for granting third-parties temporary access to individual resources using
a query parameter called _bewit_ (in falconry, a leather strap used to attach a tracking device to the leg of a hawk).</p>
<p>The <strong>Hawk</strong> scheme requires the establishment of a shared symmetric key between the client and the server,
which is beyond the scope of this module. Typically, the shared credentials are established via an initial
TLS-protected phase or derived from some other shared confidential information available to both the client
and the server.</p>
<p>## Replay Protection</p>
<p>Without replay protection, an attacker can use a compromised (but otherwise valid and authenticated) request more
than once, gaining access to a protected resource. To mitigate this, clients include both a nonce and a timestamp when
making requests. This gives the server enough information to prevent replay attacks.</p>
<p>The nonce is generated by the client, and is a string unique across all requests with the same timestamp and
key identifier combination.</p>
<p>The timestamp enables the server to restrict the validity period of the credentials where requests occuring afterwards
are rejected. It also removes the need for the server to retain an unbounded number of nonce values for future checks.
By default, <strong>Hawk</strong> uses a time window of 1 minute to allow for time skew between the client and server (which in
practice translates to a maximum of 2 minutes as the skew can be positive or negative).</p>
<p>Using a timestamp requires the client&#8217;s clock to be in sync with the server&#8217;s clock. <strong>Hawk</strong> requires both the client
clock and the server clock to use NTP to ensure synchronization. However, given the limitations of some client types
(e.g. browsers) to deploy NTP, the server provides the client with its current time (in seconds precision) in response
to a bad timestamp.</p>
<p>There is no expectation that the client will adjust its system clock to match the server (in fact, this would be a
potential attack vector). Instead, the client only uses the server&#8217;s time to calculate an offset used only
for communications with that particular server. The protocol rewards clients with synchronized clocks by reducing
the number of round trips required to authenticate the first request.</p>
<p>## Usage Example</p>
<p>Server code:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>javascript
var Http = require(&#8216;http&#8217;);
var Hawk = require(&#8216;hawk&#8217;);</p>
<p>// Credentials lookup function</p>
<p>var credentialsFunc = function (id, callback) {</p>
<blockquote>
<div><dl class="docutils">
<dt>var credentials = {</dt>
<dd>key: &#8216;werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn&#8217;,
algorithm: &#8216;sha256&#8217;,
user: &#8216;Steve&#8217;</dd>
</dl>
<p>};</p>
<p>return callback(null, credentials);</p>
</div></blockquote>
<p>};</p>
<p>// Create HTTP server</p>
<p>var handler = function (req, res) {</p>
<blockquote>
<div><p>// Authenticate incoming request</p>
<p>Hawk.server.authenticate(req, credentialsFunc, {}, function (err, credentials, artifacts) {</p>
<blockquote>
<div><p>// Prepare response</p>
<p>var payload = (!err ? &#8216;Hello &#8216; + credentials.user + &#8216; &#8216; + artifacts.ext : &#8216;Shoosh!&#8217;);
var headers = { &#8216;Content-Type&#8217;: &#8216;text/plain&#8217; };</p>
<p>// Generate Server-Authorization response header</p>
<p>var header = Hawk.server.header(credentials, artifacts, { payload: payload, contentType: headers[&#8216;Content-Type&#8217;] });
headers[&#8216;Server-Authorization&#8217;] = header;</p>
<p>// Send the response back</p>
<p>res.writeHead(!err ? 200 : 401, headers);
res.end(payload);</p>
</div></blockquote>
<p>});</p>
</div></blockquote>
<p>};</p>
<p>// Start server</p>
<p>Http.createServer(handler).listen(8000, &#8216;example.com&#8217;);
<a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>Client code:</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>javascript
var Request = require(&#8216;request&#8217;);
var Hawk = require(&#8216;hawk&#8217;);</p>
<p>// Client credentials</p>
<dl class="docutils">
<dt>var credentials = {</dt>
<dd>id: &#8216;dh37fgj492je&#8217;,
key: &#8216;werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn&#8217;,
algorithm: &#8216;sha256&#8217;</dd>
</dl>
<p>}</p>
<p>// Request options</p>
<dl class="docutils">
<dt>var requestOptions = {</dt>
<dd>uri: &#8216;<a class="reference external" href="http://example.com:8000/resource/1?b=1&amp;a=2">http://example.com:8000/resource/1?b=1&amp;a=2</a>&#8216;,
method: &#8216;GET&#8217;,
headers: {}</dd>
</dl>
<p>};</p>
<p>// Generate Authorization request header</p>
<p>var header = Hawk.client.header(&#8216;<a class="reference external" href="http://example.com:8000/resource/1?b=1&amp;a=2">http://example.com:8000/resource/1?b=1&amp;a=2</a>&#8216;, &#8216;GET&#8217;, { credentials: credentials, ext: &#8216;some-app-data&#8217; });
requestOptions.headers.Authorization = header.field;</p>
<p>// Send authenticated request</p>
<p>Request(requestOptions, function (error, response, body) {</p>
<blockquote>
<div><p>// Authenticate the server&#8217;s response</p>
<p>var isValid = Hawk.client.authenticate(response, credentials, header.artifacts, { payload: body });</p>
<p>// Output results</p>
<p>console.log(response.statusCode + &#8216;: &#8216; + body + (isValid ? &#8216; (valid)&#8217; : &#8216; (invalid)&#8217;));</p>
</div></blockquote>
<div class="section" id="id13">
<h1>});<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h1>
<p><strong>Hawk</strong> utilized the [<strong>SNTP</strong>](<a class="reference external" href="https://github.com/hueniverse/sntp">https://github.com/hueniverse/sntp</a>) module for time sync management. By default, the local
machine time is used. To automatically retrieve and synchronice the clock within the application, use the SNTP &#8216;start()&#8217; method.</p>
<p><code class="docutils literal"><span class="pre">`javascript</span>
<span class="pre">Hawk.sntp.start();</span>
<span class="pre">`</span></code></p>
<p>## Protocol Example</p>
<p>The client attempts to access a protected resource without authentication, sending the following HTTP request to
the resource server:</p>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">GET</span> <span class="pre">/resource/1?b=1&amp;a=2</span> <span class="pre">HTTP/1.1</span>
<span class="pre">Host:</span> <span class="pre">example.com:8000</span>
<span class="pre">`</span></code></p>
<p>The resource server returns an authentication challenge.</p>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">HTTP/1.1</span> <span class="pre">401</span> <span class="pre">Unauthorized</span>
<span class="pre">WWW-Authenticate:</span> <span class="pre">Hawk</span>
<span class="pre">`</span></code></p>
<p>The client has previously obtained a set of <strong>Hawk</strong> credentials for accessing resources on the &#8220;<a class="reference external" href="http://example.com/">http://example.com/</a>&#8221;
server. The <strong>Hawk</strong> credentials issued to the client include the following attributes:</p>
<ul class="simple">
<li>Key identifier: dh37fgj492je</li>
<li>Key: werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn</li>
<li>Algorithm: sha256</li>
</ul>
<p>The client generates the authentication header by calculating a timestamp (e.g. the number of seconds since January 1,
1970 00:00:00 GMT), generating a nonce, and constructing the normalized request string (each value followed by a newline
character):</p>
<p><a href="#id14"><span class="problematic" id="id15">``</span></a>`
hawk.1.header
1353832234
j4h3g2
GET
/resource/1?b=1&amp;a=2
example.com
8000</p>
<p>some-app-ext-data</p>
<p><a href="#id16"><span class="problematic" id="id17">``</span></a><a href="#id18"><span class="problematic" id="id19">`</span></a></p>
<p>The request MAC is calculated using HMAC with the specified hash algorithm &#8220;sha256&#8221; and the key over the normalized request string.
The result is base64-encoded to produce the request MAC:</p>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE=</span>
<span class="pre">`</span></code></p>
<p>The client includes the <strong>Hawk</strong> key identifier, timestamp, nonce, application specific data, and request MAC with the request using
the HTTP <cite>Authorization</cite> request header field:</p>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">GET</span> <span class="pre">/resource/1?b=1&amp;a=2</span> <span class="pre">HTTP/1.1</span>
<span class="pre">Host:</span> <span class="pre">example.com:8000</span>
<span class="pre">Authorization:</span> <span class="pre">Hawk</span> <span class="pre">id=&quot;dh37fgj492je&quot;,</span> <span class="pre">ts=&quot;1353832234&quot;,</span> <span class="pre">nonce=&quot;j4h3g2&quot;,</span> <span class="pre">ext=&quot;some-app-ext-data&quot;,</span> <span class="pre">mac=&quot;6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE=&quot;</span>
<span class="pre">`</span></code></p>
<p>The server validates the request by calculating the request MAC again based on the request received and verifies the validity
and scope of the <strong>Hawk</strong> credentials. If valid, the server responds with the requested resource.</p>
<p>### Payload Validation</p>
<p><strong>Hawk</strong> provides optional payload validation. When generating the authentication header, the client calculates a payload hash
using the specified hash algorithm. The hash is calculated over the concatenated value of (each followed by a newline character):
* <cite>hawk.1.payload</cite>
* the content-type in lowercase, without any parameters (e.g. <cite>application/json</cite>)
* the request payload prior to any content encoding (the exact representation requirements should be specified by the server for payloads other than simple single-part ascii to ensure interoperability)</p>
<p>For example:</p>
<ul class="simple">
<li>Payload: <cite>Thank you for flying Hawk</cite></li>
<li>Content Type: <cite>text/plain</cite></li>
<li>Hash (sha256): <cite>Yi9LfIIFRtBEPt74PVmbTF/xVAwPn7ub15ePICfgnuY=</cite></li>
</ul>
<p>Results in the following input to the payload hash function (newline terminated values):</p>
<p><a href="#id20"><span class="problematic" id="id21">``</span></a>`
hawk.1.payload
text/plain
Thank you for flying Hawk</p>
<p><a href="#id22"><span class="problematic" id="id23">``</span></a><a href="#id24"><span class="problematic" id="id25">`</span></a></p>
<p>Which produces the following hash value:</p>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">Yi9LfIIFRtBEPt74PVmbTF/xVAwPn7ub15ePICfgnuY=</span>
<span class="pre">`</span></code></p>
<p>The client constructs the normalized request string (newline terminated values):</p>
<p><a href="#id26"><span class="problematic" id="id27">``</span></a>`
hawk.1.header
1353832234
j4h3g2
POST
/resource/1?a=1&amp;b=2
example.com
8000
Yi9LfIIFRtBEPt74PVmbTF/xVAwPn7ub15ePICfgnuY=
some-app-ext-data</p>
<p><a href="#id28"><span class="problematic" id="id29">``</span></a><a href="#id30"><span class="problematic" id="id31">`</span></a></p>
<p>Then calculates the request MAC and includes the <strong>Hawk</strong> key identifier, timestamp, nonce, payload hash, application specific data,
and request MAC, with the request using the HTTP <cite>Authorization</cite> request header field:</p>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">POST</span> <span class="pre">/resource/1?a=1&amp;b=2</span> <span class="pre">HTTP/1.1</span>
<span class="pre">Host:</span> <span class="pre">example.com:8000</span>
<span class="pre">Authorization:</span> <span class="pre">Hawk</span> <span class="pre">id=&quot;dh37fgj492je&quot;,</span> <span class="pre">ts=&quot;1353832234&quot;,</span> <span class="pre">nonce=&quot;j4h3g2&quot;,</span> <span class="pre">hash=&quot;Yi9LfIIFRtBEPt74PVmbTF/xVAwPn7ub15ePICfgnuY=&quot;,</span> <span class="pre">ext=&quot;some-app-ext-data&quot;,</span> <span class="pre">mac=&quot;aSe1DERmZuRl3pI36/9BdZmnErTw3sNzOOAUlfeKjVw=&quot;</span>
<span class="pre">`</span></code></p>
<p>It is up to the server if and when it validates the payload for any given request, based solely on it&#8217;s security policy
and the nature of the data included.</p>
<p>If the payload is available at the time of authentication, the server uses the hash value provided by the client to construct
the normalized string and validates the MAC. If the MAC is valid, the server calculates the payload hash and compares the value
with the provided payload hash in the header. In many cases, checking the MAC first is faster than calculating the payload hash.</p>
<p>However, if the payload is not available at authentication time (e.g. too large to fit in memory, streamed elsewhere, or processed
at a different stage in the application), the server may choose to defer payload validation for later by retaining the hash value
provided by the client after validating the MAC.</p>
<p>It is important to note that MAC validation does not mean the hash value provided by the client is valid, only that the value
included in the header was not modified. Without calculating the payload hash on the server and comparing it to the value provided
by the client, the payload may be modified by an attacker.</p>
<p>## Response Payload Validation</p>
<p><strong>Hawk</strong> provides partial response payload validation. The server includes the <cite>Server-Authorization</cite> response header which enables the
client to authenticate the response and ensure it is talking to the right server. <strong>Hawk</strong> defines the HTTP <cite>Server-Authorization</cite> header
as a response header using the exact same syntax as the <cite>Authorization</cite> request header field.</p>
<p>The header is contructed using the same process as the client&#8217;s request header. The server uses the same credentials and other
artifacts provided by the client to constructs the normalized request string. The <cite>ext</cite> and <cite>hash</cite> values are replaced with
new values based on the server response. The rest as identical to those used by the client.</p>
<p>The result MAC digest is included with the optional <cite>hash</cite> and <cite>ext</cite> values:</p>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">Server-Authorization:</span> <span class="pre">Hawk</span> <span class="pre">mac=&quot;XIJRsMl/4oL+nn+vKoeVZPdCHXB4yJkNnBbTbHFZUYE=&quot;,</span> <span class="pre">hash=&quot;f9cDF/TDm7TkYRLnGwRMfeDzT6LixQVLvrIKhh0vgmM=&quot;,</span> <span class="pre">ext=&quot;response-specific&quot;</span>
<span class="pre">`</span></code></p>
<p>## Browser Support and Considerations</p>
<p>A browser script is provided for including using a <cite>&lt;script&gt;</cite> tag in [lib/browser.js](/lib/browser.js). It&#8217;s also a [component](<a class="reference external" href="http://component.io/hueniverse/hawk">http://component.io/hueniverse/hawk</a>).</p>
<p><strong>Hawk</strong> relies on the _Server-<a href="#id48"><span class="problematic" id="id49">Authorization_</span></a> and _WWW-<a href="#id50"><span class="problematic" id="id51">Authenticate_</span></a> headers in its response to communicate with the client.
Therefore, in case of CORS requests, it is important to consider sending _Access-<a href="#id52"><span class="problematic" id="id53">Control-Expose-Headers_</span></a> with the value
_&#8221;WWW-Authenticate, Server-Authorization&#8221;_ on each response from your server. As explained in the
[specifications](<a class="reference external" href="http://www.w3.org/TR/cors/#access-control-expose-headers-response-header">http://www.w3.org/TR/cors/#access-control-expose-headers-response-header</a>), it will indicate that these headers
can safely be accessed by the client (using getResponseHeader() on the XmlHttpRequest object). Otherwise you will be met with a
[&#8220;simple response header&#8221;](<a class="reference external" href="http://www.w3.org/TR/cors/#simple-response-header">http://www.w3.org/TR/cors/#simple-response-header</a>) which excludes these fields and would prevent the
Hawk client from authenticating the requests.You can read more about the why and how in this
[article](<a class="reference external" href="http://www.html5rocks.com/en/tutorials/cors/#toc-adding-cors-support-to-the-server">http://www.html5rocks.com/en/tutorials/cors/#toc-adding-cors-support-to-the-server</a>)</p>
<p># Single URI Authorization</p>
<p>There are cases in which limited and short-term access to a protected resource is granted to a third party which does not
have access to the shared credentials. For example, displaying a protected image on a web page accessed by anyone. <strong>Hawk</strong>
provides limited support for such URIs in the form of a _bewit_ - a URI query parameter appended to the request URI which contains
the necessary credentials to authenticate the request.</p>
<p>Because of the significant security risks involved in issuing such access, bewit usage is purposely limited only to GET requests
and for a finite period of time. Both the client and server can issue bewit credentials, however, the server should not use the same
credentials as the client to maintain clear traceability as to who issued which credentials.</p>
<p>In order to simplify implementation, bewit credentials do not support single-use policy and can be replayed multiple times within
the granted access timeframe.</p>
<p>## Bewit Usage Example</p>
<p>Server code:</p>
<p><a href="#id32"><span class="problematic" id="id33">``</span></a><a href="#id34"><span class="problematic" id="id35">`</span></a>javascript
var Http = require(&#8216;http&#8217;);
var Hawk = require(&#8216;hawk&#8217;);</p>
<p>// Credentials lookup function</p>
<p>var credentialsFunc = function (id, callback) {</p>
<blockquote>
<div><dl class="docutils">
<dt>var credentials = {</dt>
<dd>key: &#8216;werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn&#8217;,
algorithm: &#8216;sha256&#8217;</dd>
</dl>
<p>};</p>
<p>return callback(null, credentials);</p>
</div></blockquote>
<p>};</p>
<p>// Create HTTP server</p>
<p>var handler = function (req, res) {</p>
<blockquote>
<div><p>Hawk.uri.authenticate(req, credentialsFunc, {}, function (err, credentials, attributes) {</p>
<blockquote>
<div>res.writeHead(!err ? 200 : 401, { &#8216;Content-Type&#8217;: &#8216;text/plain&#8217; });
res.end(!err ? &#8216;Access granted&#8217; : &#8216;Shoosh!&#8217;);</div></blockquote>
<p>});</p>
</div></blockquote>
<p>};</p>
<p>Http.createServer(handler).listen(8000, &#8216;example.com&#8217;);
<a href="#id36"><span class="problematic" id="id37">``</span></a><a href="#id38"><span class="problematic" id="id39">`</span></a></p>
<p>Bewit code generation:</p>
<p><a href="#id40"><span class="problematic" id="id41">``</span></a><a href="#id42"><span class="problematic" id="id43">`</span></a>javascript
var Request = require(&#8216;request&#8217;);
var Hawk = require(&#8216;hawk&#8217;);</p>
<p>// Client credentials</p>
<dl class="docutils">
<dt>var credentials = {</dt>
<dd>id: &#8216;dh37fgj492je&#8217;,
key: &#8216;werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn&#8217;,
algorithm: &#8216;sha256&#8217;</dd>
</dl>
<p>}</p>
<p>// Generate bewit</p>
<p>var duration = 60 * 5;      // 5 Minutes
var bewit = Hawk.uri.getBewit(&#8216;<a class="reference external" href="http://example.com:8080/resource/1?b=1&amp;a=2">http://example.com:8080/resource/1?b=1&amp;a=2</a>&#8216;, { credentials: credentials, ttlSec: duration, ext: &#8216;some-app-data&#8217; });
var uri = &#8216;<a class="reference external" href="http://example.com:8000/resource/1?b=1&amp;a=2">http://example.com:8000/resource/1?b=1&amp;a=2</a>&#8216; + &#8216;&amp;bewit=&#8217; + bewit;
<a href="#id44"><span class="problematic" id="id45">``</span></a><a href="#id46"><span class="problematic" id="id47">`</span></a></p>
<p># Security Considerations</p>
<p>The greatest sources of security risks are usually found not in <strong>Hawk</strong> but in the policies and procedures surrounding its use.
Implementers are strongly encouraged to assess how this module addresses their security requirements. This section includes
an incomplete list of security considerations that must be reviewed and understood before deploying <strong>Hawk</strong> on the server.
Many of the protections provided in <strong>Hawk</strong> depends on whether and how they are used.</p>
<p>### MAC Keys Transmission</p>
<p><strong>Hawk</strong> does not provide any mechanism for obtaining or transmitting the set of shared credentials required. Any mechanism used
to obtain <strong>Hawk</strong> credentials must ensure that these transmissions are protected using transport-layer mechanisms such as TLS.</p>
<p>### Confidentiality of Requests</p>
<p>While <strong>Hawk</strong> provides a mechanism for verifying the integrity of HTTP requests, it provides no guarantee of request
confidentiality. Unless other precautions are taken, eavesdroppers will have full access to the request content. Servers should
carefully consider the types of data likely to be sent as part of such requests, and employ transport-layer security mechanisms
to protect sensitive resources.</p>
<p>### Spoofing by Counterfeit Servers</p>
<p><strong>Hawk</strong> provides limited verification of the server authenticity. When receiving a response back from the server, the server
may choose to include a response <cite>Server-Authorization</cite> header which the client can use to verify the response. However, it is up to
the server to determine when such measure is included, to up to the client to enforce that policy.</p>
<p>A hostile party could take advantage of this by intercepting the client&#8217;s requests and returning misleading or otherwise
incorrect responses. Service providers should consider such attacks when developing services using this protocol, and should
require transport-layer security for any requests where the authenticity of the resource server or of server responses is an issue.</p>
<p>### Plaintext Storage of Credentials</p>
<p>The <strong>Hawk</strong> key functions the same way passwords do in traditional authentication systems. In order to compute the request MAC,
the server must have access to the key in plaintext form. This is in contrast, for example, to modern operating systems, which
store only a one-way hash of user credentials.</p>
<p>If an attacker were to gain access to these keys - or worse, to the server&#8217;s database of all such keys - he or she would be able
to perform any action on behalf of any resource owner. Accordingly, it is critical that servers protect these keys from unauthorized
access.</p>
<p>### Entropy of Keys</p>
<p>Unless a transport-layer security protocol is used, eavesdroppers will have full access to authenticated requests and request
MAC values, and will thus be able to mount offline brute-force attacks to recover the key used. Servers should be careful to
assign keys which are long enough, and random enough, to resist such attacks for at least the length of time that the <strong>Hawk</strong>
credentials are valid.</p>
<p>For example, if the credentials are valid for two weeks, servers should ensure that it is not possible to mount a brute force
attack that recovers the key in less than two weeks. Of course, servers are urged to err on the side of caution, and use the
longest key reasonable.</p>
<p>It is equally important that the pseudo-random number generator (PRNG) used to generate these keys be of sufficiently high
quality. Many PRNG implementations generate number sequences that may appear to be random, but which nevertheless exhibit
patterns or other weaknesses which make cryptanalysis or brute force attacks easier. Implementers should be careful to use
cryptographically secure PRNGs to avoid these problems.</p>
<p>### Coverage Limitations</p>
<p>The request MAC only covers the HTTP <cite>Host</cite> header and optionally the <cite>Content-Type</cite> header. It does not cover any other headers
which can often affect how the request body is interpreted by the server. If the server behavior is influenced by the presence
or value of such headers, an attacker can manipulate the request headers without being detected. Implementers should use the
<cite>ext</cite> feature to pass application-specific information via the <cite>Authorization</cite> header which is protected by the request MAC.</p>
<p>The response authentication, when performed, only covers the response payload, content-type, and the request information
provided by the client in it&#8217;s request (method, resource, timestamp, nonce, etc.). It does not cover the HTTP status code or
any other response header field (e.g. Location) which can affect the client&#8217;s behaviour.</p>
<p>### Future Time Manipulation</p>
<p>The protocol relies on a clock sync between the client and server. To accomplish this, the server informs the client of its
current time when an invalid timestamp is received.</p>
<p>If an attacker is able to manipulate this information and cause the client to use an incorrect time, it would be able to cause
the client to generate authenticated requests using time in the future. Such requests will fail when sent by the client, and will
not likely leave a trace on the server (given the common implementation of nonce, if at all enforced). The attacker will then
be able to replay the request at the correct time without detection.</p>
<p>The client must only use the time information provided by the server if:
* it was delivered over a TLS connection and the server identity has been verified, or
* the <cite>tsm</cite> MAC digest calculated using the same client credentials over the timestamp has been verified.</p>
<p>### Client Clock Poisoning</p>
<p>When receiving a request with a bad timestamp, the server provides the client with its current time. The client must never use
the time received from the server to adjust its own clock, and must only use it to calculate an offset for communicating with
that particular server.</p>
<p>### Bewit Limitations</p>
<p>Special care must be taken when issuing bewit credentials to third parties. Bewit credentials are valid until expiration and cannot
be revoked or limited without using other means. Whatever resource they grant access to will be completely exposed to anyone with
access to the bewit credentials which act as bearer credentials for that particular resource. While bewit usage is limited to GET
requests only and therefore cannot be used to perform transactions or change server state, it can still be used to expose private
and sensitive information.</p>
<p>### Host Header Forgery</p>
<p>Hawk validates the incoming request MAC against the incoming HTTP Host header. However, unless the optional <cite>host</cite> and <cite>port</cite>
options are used with <cite>server.authenticate()</cite>, a malicous client can mint new host names pointing to the server&#8217;s IP address and
use that to craft an attack by sending a valid request that&#8217;s meant for another hostname than the one used by the server. Server
implementors must manually verify that the host header received matches their expectation (or use the options mentioned above).</p>
<p># Frequently Asked Questions</p>
<p>### Where is the protocol specification?</p>
<p>If you are looking for some prose explaining how all this works, <strong>this is it</strong>. <strong>Hawk</strong> is being developed as an open source
project instead of a standard. In other words, the [code](/hueniverse/hawk/tree/master/lib) is the specification. Not sure about
something? Open an issue!</p>
<p>### Is it done?</p>
<p>As of version 0.10.0, <strong>Hawk</strong> is feature-complete. However, until this module reaches version 1.0.0 it is considered experimental
and is likely to change. This also means your feedback and contribution are very welcome. Feel free to open issues with questions
and suggestions.</p>
<p>### Where can I find <strong>Hawk</strong> implementations in other languages?</p>
<p><strong>Hawk</strong>&#8216;s only reference implementation is provided in JavaScript as a node.js module. However, it has been ported to other languages.
The full list is maintained [here](<a class="reference external" href="https://github.com/hueniverse/hawk/issues?labels=port&amp;state=closed">https://github.com/hueniverse/hawk/issues?labels=port&amp;state=closed</a>). Please add an issue if you are
working on another port. A cross-platform test-suite is in the works.</p>
<p>### Why isn&#8217;t the algorithm part of the challenge or dynamically negotiated?</p>
<p>The algorithm used is closely related to the key issued as different algorithms require different key sizes (and other
requirements). While some keys can be used for multiple algorithm, the protocol is designed to closely bind the key and algorithm
together as part of the issued credentials.</p>
<p>### Why is Host and Content-Type the only headers covered by the request MAC?</p>
<p>It is really hard to include other headers. Headers can be changed by proxies and other intermediaries and there is no
well-established way to normalize them. Many platforms change the case of header field names and values. The only
straight-forward solution is to include the headers in some blob (say, base64 encoded JSON) and include that with the request,
an approach taken by JWT and other such formats. However, that design violates the HTTP header boundaries, repeats information,
and introduces other security issues because firewalls will not be aware of these &#8220;hidden&#8221; headers. In addition, any information
repeated must be compared to the duplicated information in the header and therefore only moves the problem elsewhere.</p>
<p>### Why not just use HTTP Digest?</p>
<p>Digest requires pre-negotiation to establish a nonce. This means you can&#8217;t just make a request - you must first send
a protocol handshake to the server. This pattern has become unacceptable for most web services, especially mobile
where extra round-trip are costly.</p>
<p>### Why bother with all this nonce and timestamp business?</p>
<p><strong>Hawk</strong> is an attempt to find a reasonable, practical compromise between security and usability. OAuth 1.0 got timestamp
and nonces halfway right but failed when it came to scalability and consistent developer experience. <strong>Hawk</strong> addresses
it by requiring the client to sync its clock, but provides it with tools to accomplish it.</p>
<p>In general, replay protection is a matter of application-specific threat model. It is less of an issue on a TLS-protected
system where the clients are implemented using best practices and are under the control of the server. Instead of dropping
replay protection, <strong>Hawk</strong> offers a required time window and an optional nonce verification. Together, it provides developers
with the ability to decide how to enforce their security policy without impacting the client&#8217;s implementation.</p>
<p>### What are <cite>app</cite> and <cite>dlg</cite> in the authorization header and normalized mac string?</p>
<p>The original motivation for <strong>Hawk</strong> was to replace the OAuth 1.0 use cases. This included both a simple client-server mode which
this module is specifically designed for, and a delegated access mode which is being developed separately in
[Oz](<a class="reference external" href="https://github.com/hueniverse/oz">https://github.com/hueniverse/oz</a>). In addition to the <strong>Hawk</strong> use cases, Oz requires another attribute: the application id <cite>app</cite>.
This provides binding between the credentials and the application in a way that prevents an attacker from tricking an application
to use credentials issued to someone else. It also has an optional &#8216;delegated-by&#8217; attribute <cite>dlg</cite> which is the application id of the
application the credentials were directly issued to. The goal of these two additions is to allow Oz to utilize <strong>Hawk</strong> directly,
but with the additional security of delegated credentials.</p>
<p>### What is the purpose of the static strings used in each normalized MAC input?</p>
<p>When calculating a hash or MAC, a static prefix (tag) is added. The prefix is used to prevent MAC values from being
used or reused for a purpose other than what they were created for (i.e. prevents switching MAC values between a request,
response, and a bewit use cases). It also protects against exploits created after a potential change in how the protocol
creates the normalized string. For example, if a future version would switch the order of nonce and timestamp, it
can create an exploit opportunity for cases where the nonce is similar in format to a timestamp.</p>
<p>### Does <strong>Hawk</strong> have anything to do with OAuth?</p>
<p>Short answer: no.</p>
<p><strong>Hawk</strong> was originally proposed as the OAuth MAC Token specification. However, the OAuth working group in its consistent
incompetence failed to produce a final, usable solution to address one of the most popular use cases of OAuth 1.0 - using it
to authenticate simple client-server transactions (i.e. two-legged). As you can guess, the OAuth working group is still hard
at work to produce more garbage.</p>
<p><strong>Hawk</strong> provides a simple HTTP authentication scheme for making client-server requests. It does not address the OAuth use case
of delegating access to a third party. If you are looking for an OAuth alternative, check out [Oz](<a class="reference external" href="https://github.com/hueniverse/oz">https://github.com/hueniverse/oz</a>).</p>
<p># Implementations</p>
<ul class="simple">
<li>[Logibit Hawk in F#/.Net](<a class="reference external" href="https://github.com/logibit/logibit.hawk/">https://github.com/logibit/logibit.hawk/</a>)</li>
<li>[Tent Hawk in Ruby](<a class="reference external" href="https://github.com/tent/hawk-ruby">https://github.com/tent/hawk-ruby</a>)</li>
<li>[Wealdtech in Java](<a class="reference external" href="https://github.com/wealdtech/hawk">https://github.com/wealdtech/hawk</a>)</li>
<li>[Kumar&#8217;s Mohawk in Python](<a class="reference external" href="https://github.com/kumar303/mohawk/">https://github.com/kumar303/mohawk/</a>)</li>
</ul>
<p># Acknowledgements</p>
<p><strong>Hawk</strong> is a derivative work of the [HTTP MAC Authentication Scheme](<a class="reference external" href="http://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05">http://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05</a>) proposal
co-authored by Ben Adida, Adam Barth, and Eran Hammer, which in turn was based on the OAuth 1.0 community specification.</p>
<p>Special thanks to Ben Laurie for his always insightful feedback and advice.</p>
<p>The <strong>Hawk</strong> logo was created by [Chris Carrasco](<a class="reference external" href="http://chriscarrasco.com">http://chriscarrasco.com</a>).</p>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright © NFLabs. All rights reserved..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../../../../../../../../../../../../../../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../../../../../../../../../../../../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../../../../../../../../../../../../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../../../../../../../../../../../../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../../../../../../../../../../../../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>